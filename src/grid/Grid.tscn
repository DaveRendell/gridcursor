[gd_scene load_steps=5 format=3 uid="uid://djsa1g15xsllf"]

[ext_resource type="Texture2D" uid="uid://c68j4qg2ycu3j" path="res://img/ui/grid/cursor/0.png" id="2"]
[ext_resource type="Texture2D" uid="uid://di4gneiov1ioj" path="res://img/ui/grid/cursor/1.png" id="3"]

[sub_resource type="GDScript" id="GDScript_oy46f"]
script/source = "extends Node2D

class_name Grid
# Scene representing a scene containing a grid of user interactable objects, e.g.
# a menu, a battle map, a hex grid...
# This scene is abstract, and must have various methods implemented by 
# inheriting scenes

@export var grid_size: int = 16
@export var grid_width: int = 20
@export var grid_height: int = 20

var geometry: Geometry

# Cursor properties
var cursor: Vector2i = Vector2i(0, 0)
var mouse_in_grid = false
var scrolling: bool = false

var clickable_cells: Array[Vector2i] = []

signal click
signal cursor_move

enum GridState {
	NOTHING_SELECTED, # Cursor active, select units checked click
	IN_MENU, # Hide cursor, accept no input
	UNIT_CONTROLLED # Input passed to selected unit, limited options for selection
}
var state = GridState.NOTHING_SELECTED

func set_state_nothing_selected() -> void:
	print(\"Grid state: Nothing Selected\")
	state = GridState.NOTHING_SELECTED
	
	$Cursor.visible = true
	clickable_cells = []

func set_state_in_menu() -> void:
	print(\"Grid state: In Menu\")
	state = GridState.IN_MENU
	
	$Cursor.visible = false
	clickable_cells = []

func set_state_unit_controlled(clickable_cells: Array[Vector2i]) -> void:
	print(\"Grid state: Unit Controlled\")
	state = GridState.UNIT_CONTROLLED
	
	$Cursor.visible = true
	self.clickable_cells = clickable_cells

func set_position_to_mouse_cursor() -> void:
	var mouse_relative_position = get_global_mouse_position() - global_position
	var coordinate = geometry.cell_containing_position(mouse_relative_position)
	if not cursor == coordinate:
		cursor = coordinate.clamp(Vector2i.ZERO, Vector2i(grid_width, grid_height))
		if state == GridState.UNIT_CONTROLLED:
			emit_signal(\"cursor_move\", self)
		$Cursor.position = geometry.cell_centre_position(cursor)

func move_cursor(dx: int, dy: int):
	cursor = cursor + Vector2i(dx, dy)
	if state == GridState.UNIT_CONTROLLED:
		emit_signal(\"cursor_move\", self)
	$Cursor.position = geometry.cell_centre_position(cursor)

func _input(event):
	if state == GridState.NOTHING_SELECTED or state == GridState.UNIT_CONTROLLED:
		if event.is_action_pressed(\"ui_up\") and cursor.y > 0:
			move_cursor(0, -1)
			$Cursor/ScrollStartTimer.start()
		if event.is_action_pressed(\"ui_down\") and cursor.y < grid_height - 1:
			move_cursor(0, 1)
			$Cursor/ScrollStartTimer.start()
		if event.is_action_pressed(\"ui_left\") and cursor.x > 0:
			move_cursor(-1, 0)
			$Cursor/ScrollStartTimer.start()
		if event.is_action_pressed(\"ui_right\") and cursor.x < grid_width - 1:
			move_cursor(1, 0)
			$Cursor/ScrollStartTimer.start()
		
		if event.is_action_released(\"ui_up\") \\
		or event.is_action_released(\"ui_down\")\\
		or event.is_action_released(\"ui_left\")\\
		or event.is_action_released(\"ui_right\"):
			$Cursor/ScrollStartTimer.stop()
			$Cursor/ScrollTickTimer.stop()
			scrolling = false
		
		if event is InputEventMouseMotion and mouse_in_grid:
			set_position_to_mouse_cursor()
			
		if event.is_action_pressed(\"ui_accept\"):
			click_position(cursor)
			
		if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT and !event.is_pressed():
			set_position_to_mouse_cursor()
			click_position(cursor)
		
		if event.is_action_pressed(\"ui_cancel\")\\
		|| (event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_RIGHT and !event.is_pressed()):
			emit_signal(\"click\", \"cancel\")


func scroll_cursor():
	if Input.is_action_pressed(\"ui_up\") and cursor.y > 0:
		move_cursor(0, -1)
	if Input.is_action_pressed(\"ui_down\") and cursor.y < grid_height - 1:
		move_cursor(0, 1)
	if Input.is_action_pressed(\"ui_left\") and cursor.x > 0:
		move_cursor(-1, 0)
	if Input.is_action_pressed(\"ui_right\") and cursor.x < grid_width - 1:
		move_cursor(1, 0)

func click_position(coordinate: Vector2i):
	push_error(\"Implement click_position in inheriting scene\")

# Signals
func _on_Background_mouse_entered():
	mouse_in_grid = true


func _on_Background_mouse_exited():
	mouse_in_grid = false


func _on_ScrollStartTimer_timeout():
	scrolling = true
	$Cursor/ScrollTickTimer.start()
	scroll_cursor()


func _on_ScrollTickTimer_timeout():
	scroll_cursor()
"

[sub_resource type="SpriteFrames" id="2"]
animations = [{
"frames": [ExtResource("2"), ExtResource("3")],
"loop": true,
"name": &"default",
"speed": 5.0
}]

[node name="Grid" type="Node2D"]
script = SubResource("GDScript_oy46f")

[node name="Background" type="ColorRect" parent="."]
offset_right = 32.0
offset_bottom = 32.0
color = Color(1, 1, 1, 0)

[node name="Cursor" type="AnimatedSprite2D" parent="."]
z_index = 5
frames = SubResource("2")
playing = true

[node name="ScrollStartTimer" type="Timer" parent="Cursor"]
wait_time = 0.5
one_shot = true

[node name="ScrollTickTimer" type="Timer" parent="Cursor"]
wait_time = 0.1

[node name="GridNodes" type="Node" parent="."]

[connection signal="mouse_entered" from="Background" to="." method="_on_Background_mouse_entered"]
[connection signal="mouse_exited" from="Background" to="." method="_on_Background_mouse_exited"]
[connection signal="timeout" from="Cursor/ScrollStartTimer" to="." method="_on_ScrollStartTimer_timeout"]
[connection signal="timeout" from="Cursor/ScrollTickTimer" to="." method="_on_ScrollTickTimer_timeout"]
